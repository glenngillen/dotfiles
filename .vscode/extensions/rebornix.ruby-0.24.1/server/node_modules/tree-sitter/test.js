// Generic, not generated
function parseToStaticNode(sourceCode, language) {
    // Get the raw syntax tree.
    var parser = new Parser();
    parser.setLanguage(Python);
    var tree = parser.parse(sourceCode);
    var cursor = tree.walk();
    // Walk the syntax tree depth first, keeping a stack of field maps
    var fieldMapStack = [];
    var visitedChildren = false;
    while (true) {
        // Each node is visited twice:
        // once on the way down, and once on the way up.
        var node = cursor.currentNode;
        // On the way up, all of the node's fields will have been collected
        // into the field map.
        if (visitedChildren) {
            // Convert the field map into a strongly-typed node using the
            // generated conversion function.
            var typedNode = convertFieldMapToTypedNode(node, fieldMapStack.pop());
            // Insert the strongly-typed node into it's parent field map.
            var parentFieldMap = fieldMapStack[fieldMapStack.length - 1];
            if (!parentFieldMap)
                return typedNode;
            var fieldName = cursor.currentFieldName;
            if (fieldName) {
                if (!parentFieldMap[fieldName])
                    parentFieldMap[fieldName] = [];
                parentFieldMap[fieldName].push(typedNode);
            }
            // If there is a next sibling, move forward in the tree.
            if (cursor.gotoNextSibling()) {
                fieldMapStack.push({ type: cursor.currentNode.type });
                visitedChildren = false;
            }
            // If there is a parent, move up in the tree, otherwise terminate.
            else if (!cursor.gotoParent()) {
                return typedNode;
            }
        }
        // On the way down, push a new field map onto the stack.
        else if (cursor.gotoFirstChild()) {
            fieldMapStack.push({ type: cursor.currentNode.type });
        }
        else {
            visitedChildren = true;
        }
    }
}
// Generated data types
var ParametersNode = /** @class */ (function () {
    function ParametersNode() {
        // TODO - add fields for parameters
    }
    return ParametersNode;
}());
var IdentifierNode = /** @class */ (function () {
    function IdentifierNode(text) {
        this.text = text;
    }
    return IdentifierNode;
}());
var PrintStatementNode = /** @class */ (function () {
    function PrintStatementNode(args) {
        this.arguments = args;
    }
    return PrintStatementNode;
}());
var IfStatementNode = /** @class */ (function () {
    function IfStatementNode(condition, consequence, alternatives) {
        this.condition = condition;
        this.consequence = consequence;
        this.alternatives = alternatives;
    }
    return IfStatementNode;
}());
var FunctionDefinition = /** @class */ (function () {
    function FunctionDefinition(name, parameters, body) {
        this.name = name;
        this.parameters = parameters;
        this.body = body;
    }
    return FunctionDefinition;
}());
var BlockNode = /** @class */ (function () {
    function BlockNode(statements) {
        this.statements = statements;
    }
    return BlockNode;
}());
var ElifClause = /** @class */ (function () {
    function ElifClause(condition, consequence) {
        this.condition = condition;
        this.consequence = consequence;
    }
    return ElifClause;
}());
// Generated node conversion function
function convertFieldMapToTypedNode(node, fieldMap) {
    switch (fieldMap.type) {
        case 'if_statement':
            return new IfStatementNode(fieldMap.condition[0], fieldMap.consequence[0], fieldMap.alternative);
        case 'function_definition':
            return new FunctionDefinition(fieldMap.name[0], fieldMap.parameters[0], fieldMap.body[0]);
        case 'block':
            return new BlockNode(fieldMap.statement);
        case 'elif_clause':
            return new ElifClause(fieldMap.condition, fieldMap.consequence);
        case 'identifier':
            return new IdentifierNode(node.text);
        default:
            return fieldMap;
    }
}
// Test program
var fs = require('fs');
var Parser = require('.');
var Python = require('../tree-sitter-python');
var filePath = process.argv[2];
var sourceCode = fs.readFileSync(filePath, 'utf8');
var root = parseToStaticNode(sourceCode, Python);
console.log('root', JSON.stringify(root, null, 2));
